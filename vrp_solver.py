import subprocess
import os

def ensure_binaries():
    """
    Compiles C++ source files into Linux binaries if they don't exist.
    This is necessary because .exe files from Windows won't work on Streamlit.
    """
    # Mapping of expected binary names to their C++ source paths
    algos = {
        "brute_force": "cpp_algorithms/brute_force.cpp",
        "nearest_neighbor": "cpp_algorithms/nearest_neighbor.cpp",
        "clarke_wright": "cpp_algorithms/clarke_wright.cpp",
        "genetic_algorithm": "cpp_algorithms/genetic_algorithm.cpp",
        "simulated_annealing": "cpp_algorithms/simulated_annealing.cpp"
    }
    
    for exec_name, source in algos.items():
        # Check if the Linux binary exists; if not, compile it
        if not os.path.exists(exec_name):
            if os.path.exists(source):
                try:
                    # Compile using g++ (requires g++ in packages.txt)
                    subprocess.run(["g++", "-O3", source, "-o", exec_name], check=True)
                    # Grant execution permissions for the Linux environment
                    os.chmod(exec_name, 0o755)
                except subprocess.CalledProcessError as e:
                    print(f"Error compiling {source}: {e}")
            else:
                print(f"Source file {source} not found.")

def save_matrix(matrix, filename="input.txt"):
    with open(filename, "w") as f:
        f.write(str(len(matrix)) + "\n")
        for row in matrix:
            f.write(" ".join(map(str, row)) + "\n")

def load_output(filename="output.txt"):
    routes = []
    if not os.path.exists(filename):
        return routes
    with open(filename) as f:
        for line in f:
            route = list(map(int, line.strip().split()))
            routes.append(route)
    return routes

def solve_vrp(matrix, algo_name):
    # Step 1: Ensure C++ binaries are compiled for the current environment
    ensure_binaries()

    # Step 2: Map algorithm names to the newly compiled Linux binaries
    algo_execs = {
        "Brute Force": "./brute_force",
        "Nearest Neighbor": "./nearest_neighbor",
        "Clarke Wright": "./clarke_wright",
        "Genetic Algorithm": "./genetic_algorithm",
        "Simulated Annealing": "./simulated_annealing"
    }
    
    # Get number of vehicles
    num_vehicles = 2
    if os.path.exists("num_vehicles.txt"):
        with open("num_vehicles.txt") as f:
            try:
                num_vehicles = int(f.read().strip())
            except ValueError:
                num_vehicles = 2
    
    # Save input data for the C++ solver
    save_matrix(matrix)
    
    # Run the selected algorithm with num_vehicles as argument
    if algo_name in algo_execs:
        cmd = [algo_execs[algo_name], str(num_vehicles)]
        # Use check=True to catch errors during execution
        subprocess.run(cmd, stdout=subprocess.PIPE, check=True)
    
    # Load and return routes from the output.txt generated by the C++ solver
    return load_output()